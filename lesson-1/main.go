package main

import (
	"fmt"
	"os"
	"time"
)

func main() {
	/*
		1. Для закрепления навыков отложенного вызова функций, напишите программу, содержащую
		вызов функции, которая будет создавать паническую ситуацию неявно. Затем создайте
		отложенный вызов, который будет обрабатывать эту паническую ситуацию и, в частности,
			печатать предупреждение в консоль. Критерием успешного выполнения задания является то,
			что программа не завершается аварийно ни при каких условиях.
		2. Дополните функцию из п.1 возвратом собственной ошибки в случае возникновения панической
		ситуации. Собственная ошибка должна хранить время обнаружения панической ситуации.
			Критерием успешного выполнения задания является наличие обработки созданной ошибки в
		функции main и вывод ее состояния в консоль*/
	division(1, 0)

	/*	3. Для закрепления практических навыков программирования, напишите программу, которая
		создаёт один миллион пустых файлов в известной, пустой директории файловой системы
		используя вызов os.Create. Ввиду наличия определенных ограничений операционной
		системы на число открытых файлов, такая программа должна выполнять аварийную
		остановку. Запустите программу и дождитесь полученной ошибки. Используя отложенный вызов функции закрытия файла, стабилизируйте работу приложения.
	*/
	fileCreation()
}

type ErrorWithTime struct {
	text string
	time time.Time
}

func New(text string) error {
	return &ErrorWithTime{
		text: text,
		time: time.Now(),
	}
}

func (e *ErrorWithTime) Error() string {
	return fmt.Sprintf("error: %s\ntime: %s", e.text, e.time)
}

func division(a, b int) (int, error) {
	var err error
	if b == 0 {
		err = New("divided by zero")
	}
	defer func() {
		if v := recover(); v != nil {
			fmt.Println("recovered", v)
			fmt.Println(err)
		}
	}()
	return a / b, err
}

func fileCreation() error {
	for i := 1; i <= 10000; i++ {
		file, err := os.Create(fmt.Sprintf("for-files/%v.txt", i))
		if err != nil {
			return err
		}
		defer file.Close()
	}
	return nil
}
